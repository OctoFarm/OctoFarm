{"version":3,"names":[],"mappings":"","sources":["runtime.js"],"sourcesContent":["/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nconst regeneratorRuntime = (function (exports) {\r\n    \"use strict\";\r\n\r\n    const Op = Object.prototype;\r\n    const hasOwn = Op.hasOwnProperty;\r\n    let undefined; // More compressible than void 0.\r\n    const $Symbol = typeof Symbol === \"function\" ? Symbol : {};\r\n    const iteratorSymbol = $Symbol.iterator || \"@@iterator\";\r\n    const asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\r\n    const toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\r\n\r\n    function wrap(innerFn, outerFn, self, tryLocsList) {\r\n        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\r\n        const protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\r\n        const generator = Object.create(protoGenerator.prototype);\r\n        const context = new Context(tryLocsList || []);\r\n\r\n        // The ._invoke method unifies the implementations of the .next,\r\n        // .throw, and .return methods.\r\n        generator._invoke = makeInvokeMethod(innerFn, self, context);\r\n\r\n        return generator;\r\n    }\r\n    exports.wrap = wrap;\r\n\r\n    // Try/catch helper to minimize deoptimizations. Returns a completion\r\n    // record like context.tryEntries[i].completion. This interface could\r\n    // have been (and was previously) designed to take a closure to be\r\n    // invoked without arguments, but in all the cases we care about we\r\n    // already have an existing method we want to call, so there's no need\r\n    // to create a new function object. We can even get away with assuming\r\n    // the method takes exactly one argument, since that happens to be true\r\n    // in every case, so we don't have to touch the arguments object. The\r\n    // only additional allocation required is the completion record, which\r\n    // has a stable shape and so hopefully should be cheap to allocate.\r\n    function tryCatch(fn, obj, arg) {\r\n        try {\r\n            return { type: \"normal\", arg: fn.call(obj, arg) };\r\n        } catch (err) {\r\n            return { type: \"throw\", arg: err };\r\n        }\r\n    }\r\n\r\n    const GenStateSuspendedStart = \"suspendedStart\";\r\n    const GenStateSuspendedYield = \"suspendedYield\";\r\n    const GenStateExecuting = \"executing\";\r\n    const GenStateCompleted = \"completed\";\r\n\r\n    // Returning this object from the innerFn has the same effect as\r\n    // breaking out of the dispatch switch statement.\r\n    const ContinueSentinel = {};\r\n\r\n    // Dummy constructor functions that we use as the .constructor and\r\n    // .constructor.prototype properties for functions that return Generator\r\n    // objects. For full spec compliance, you may wish to configure your\r\n    // minifier not to mangle the names of these two functions.\r\n    function Generator() {}\r\n    function GeneratorFunction() {}\r\n    function GeneratorFunctionPrototype() {}\r\n\r\n    // This is a polyfill for %IteratorPrototype% for environments that\r\n    // don't natively support it.\r\n    let IteratorPrototype = {};\r\n    IteratorPrototype[iteratorSymbol] = function () {\r\n        return this;\r\n    };\r\n\r\n    const getProto = Object.getPrototypeOf;\r\n    const NativeIteratorPrototype = getProto && getProto(getProto(values([])));\r\n    if (NativeIteratorPrototype &&\r\n        NativeIteratorPrototype !== Op &&\r\n        hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\r\n        // This environment has a native %IteratorPrototype%; use it instead\r\n        // of the polyfill.\r\n        IteratorPrototype = NativeIteratorPrototype;\r\n    }\r\n\r\n    const Gp = GeneratorFunctionPrototype.prototype =\r\n        Generator.prototype = Object.create(IteratorPrototype);\r\n    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\r\n    GeneratorFunctionPrototype.constructor = GeneratorFunction;\r\n    GeneratorFunctionPrototype[toStringTagSymbol] =\r\n        GeneratorFunction.displayName = \"GeneratorFunction\";\r\n\r\n    // Helper for defining the .next, .throw, and .return methods of the\r\n    // Iterator interface in terms of a single ._invoke method.\r\n    function defineIteratorMethods(prototype) {\r\n        [\"next\", \"throw\", \"return\"].forEach(function(method) {\r\n            prototype[method] = function(arg) {\r\n                return this._invoke(method, arg);\r\n            };\r\n        });\r\n    }\r\n\r\n    exports.isGeneratorFunction = function(genFun) {\r\n        const ctor = typeof genFun === \"function\" && genFun.constructor;\r\n        return ctor\r\n            ? ctor === GeneratorFunction ||\r\n            // For the native GeneratorFunction constructor, the best we can\r\n            // do is to check its .name property.\r\n            (ctor.displayName || ctor.name) === \"GeneratorFunction\"\r\n            : false;\r\n    };\r\n\r\n    exports.mark = function(genFun) {\r\n        if (Object.setPrototypeOf) {\r\n            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\r\n        } else {\r\n            genFun.__proto__ = GeneratorFunctionPrototype;\r\n            if (!(toStringTagSymbol in genFun)) {\r\n                genFun[toStringTagSymbol] = \"GeneratorFunction\";\r\n            }\r\n        }\r\n        genFun.prototype = Object.create(Gp);\r\n        return genFun;\r\n    };\r\n\r\n    // Within the body of any async function, `await x` is transformed to\r\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\r\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\r\n    // meant to be awaited.\r\n    exports.awrap = function(arg) {\r\n        return { __await: arg };\r\n    };\r\n\r\n    function AsyncIterator(generator) {\r\n        function invoke(method, arg, resolve, reject) {\r\n            const record = tryCatch(generator[method], generator, arg);\r\n            if (record.type === \"throw\") {\r\n                reject(record.arg);\r\n            } else {\r\n                const result = record.arg;\r\n                const value = result.value;\r\n                if (value &&\r\n                    typeof value === \"object\" &&\r\n                    hasOwn.call(value, \"__await\")) {\r\n                    return Promise.resolve(value.__await).then(function(value) {\r\n                        invoke(\"next\", value, resolve, reject);\r\n                    }, function(err) {\r\n                        invoke(\"throw\", err, resolve, reject);\r\n                    });\r\n                }\r\n\r\n                return Promise.resolve(value).then(function(unwrapped) {\r\n                    // When a yielded Promise is resolved, its final value becomes\r\n                    // the .value of the Promise<{value,done}> result for the\r\n                    // current iteration.\r\n                    result.value = unwrapped;\r\n                    resolve(result);\r\n                }, function(error) {\r\n                    // If a rejected Promise was yielded, throw the rejection back\r\n                    // into the async generator function so it can be handled there.\r\n                    return invoke(\"throw\", error, resolve, reject);\r\n                });\r\n            }\r\n        }\r\n\r\n        let previousPromise;\r\n\r\n        function enqueue(method, arg) {\r\n            function callInvokeWithMethodAndArg() {\r\n                return new Promise(function(resolve, reject) {\r\n                    invoke(method, arg, resolve, reject);\r\n                });\r\n            }\r\n\r\n            return previousPromise =\r\n                // If enqueue has been called before, then we want to wait until\r\n                // all previous Promises have been resolved before calling invoke,\r\n                // so that results are always delivered in the correct order. If\r\n                // enqueue has not been called before, then it is important to\r\n                // call invoke immediately, without waiting on a callback to fire,\r\n                // so that the async generator function has the opportunity to do\r\n                // any necessary setup in a predictable way. This predictability\r\n                // is why the Promise constructor synchronously invokes its\r\n                // executor callback, and why async functions synchronously\r\n                // execute code before the first await. Since we implement simple\r\n                // async functions in terms of async generators, it is especially\r\n                // important to get this right, even though it requires care.\r\n                previousPromise ? previousPromise.then(\r\n                    callInvokeWithMethodAndArg,\r\n                    // Avoid propagating failures to Promises returned by later\r\n                    // invocations of the iterator.\r\n                    callInvokeWithMethodAndArg\r\n                ) : callInvokeWithMethodAndArg();\r\n        }\r\n\r\n        // Define the unified helper method that is used to implement .next,\r\n        // .throw, and .return (see defineIteratorMethods).\r\n        this._invoke = enqueue;\r\n    }\r\n\r\n    defineIteratorMethods(AsyncIterator.prototype);\r\n    AsyncIterator.prototype[asyncIteratorSymbol] = function () {\r\n        return this;\r\n    };\r\n    exports.AsyncIterator = AsyncIterator;\r\n\r\n    // Note that simple async functions are implemented on top of\r\n    // AsyncIterator objects; they just return a Promise for the value of\r\n    // the final result produced by the iterator.\r\n    exports.async = function(innerFn, outerFn, self, tryLocsList) {\r\n        const iter = new AsyncIterator(\r\n            wrap(innerFn, outerFn, self, tryLocsList)\r\n        );\r\n\r\n        return exports.isGeneratorFunction(outerFn)\r\n            ? iter // If outerFn is a generator, return the full iterator.\r\n            : iter.next().then(function(result) {\r\n                return result.done ? result.value : iter.next();\r\n            });\r\n    };\r\n\r\n    function makeInvokeMethod(innerFn, self, context) {\r\n        let state = GenStateSuspendedStart;\r\n\r\n        return function invoke(method, arg) {\r\n            if (state === GenStateExecuting) {\r\n                throw new Error(\"Generator is already running\");\r\n            }\r\n\r\n            if (state === GenStateCompleted) {\r\n                if (method === \"throw\") {\r\n                    throw arg;\r\n                }\r\n\r\n                // Be forgiving, per 25.3.3.3.3 of the spec:\r\n                // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\r\n                return doneResult();\r\n            }\r\n\r\n            context.method = method;\r\n            context.arg = arg;\r\n\r\n            while (true) {\r\n                const delegate = context.delegate;\r\n                if (delegate) {\r\n                    const delegateResult = maybeInvokeDelegate(delegate, context);\r\n                    if (delegateResult) {\r\n                        if (delegateResult === ContinueSentinel) continue;\r\n                        return delegateResult;\r\n                    }\r\n                }\r\n\r\n                if (context.method === \"next\") {\r\n                    // Setting context._sent for legacy support of Babel's\r\n                    // function.sent implementation.\r\n                    context.sent = context._sent = context.arg;\r\n\r\n                } else if (context.method === \"throw\") {\r\n                    if (state === GenStateSuspendedStart) {\r\n                        state = GenStateCompleted;\r\n                        throw context.arg;\r\n                    }\r\n\r\n                    context.dispatchException(context.arg);\r\n\r\n                } else if (context.method === \"return\") {\r\n                    context.abrupt(\"return\", context.arg);\r\n                }\r\n\r\n                state = GenStateExecuting;\r\n\r\n                const record = tryCatch(innerFn, self, context);\r\n                if (record.type === \"normal\") {\r\n                    // If an exception is thrown from innerFn, we leave state ===\r\n                    // GenStateExecuting and loop back for another invocation.\r\n                    state = context.done\r\n                        ? GenStateCompleted\r\n                        : GenStateSuspendedYield;\r\n\r\n                    if (record.arg === ContinueSentinel) {\r\n                        continue;\r\n                    }\r\n\r\n                    return {\r\n                        value: record.arg,\r\n                        done: context.done\r\n                    };\r\n\r\n                } else if (record.type === \"throw\") {\r\n                    state = GenStateCompleted;\r\n                    // Dispatch the exception by looping back around to the\r\n                    // context.dispatchException(context.arg) call above.\r\n                    context.method = \"throw\";\r\n                    context.arg = record.arg;\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    // Call delegate.iterator[context.method](context.arg) and handle the\r\n    // result, either by returning a { value, done } result from the\r\n    // delegate iterator, or by modifying context.method and context.arg,\r\n    // setting context.delegate to null, and returning the ContinueSentinel.\r\n    function maybeInvokeDelegate(delegate, context) {\r\n        const method = delegate.iterator[context.method];\r\n        if (method === undefined) {\r\n            // A .throw or .return when the delegate iterator has no .throw\r\n            // method always terminates the yield* loop.\r\n            context.delegate = null;\r\n\r\n            if (context.method === \"throw\") {\r\n                // Note: [\"return\"] must be used for ES3 parsing compatibility.\r\n                if (delegate.iterator[\"return\"]) {\r\n                    // If the delegate iterator has a return method, give it a\r\n                    // chance to clean up.\r\n                    context.method = \"return\";\r\n                    context.arg = undefined;\r\n                    maybeInvokeDelegate(delegate, context);\r\n\r\n                    if (context.method === \"throw\") {\r\n                        // If maybeInvokeDelegate(context) changed context.method from\r\n                        // \"return\" to \"throw\", let that override the TypeError below.\r\n                        return ContinueSentinel;\r\n                    }\r\n                }\r\n\r\n                context.method = \"throw\";\r\n                context.arg = new TypeError(\r\n                    \"The iterator does not provide a 'throw' method\");\r\n            }\r\n\r\n            return ContinueSentinel;\r\n        }\r\n\r\n        const record = tryCatch(method, delegate.iterator, context.arg);\r\n\r\n        if (record.type === \"throw\") {\r\n            context.method = \"throw\";\r\n            context.arg = record.arg;\r\n            context.delegate = null;\r\n            return ContinueSentinel;\r\n        }\r\n\r\n        const info = record.arg;\r\n\r\n        if (! info) {\r\n            context.method = \"throw\";\r\n            context.arg = new TypeError(\"iterator result is not an object\");\r\n            context.delegate = null;\r\n            return ContinueSentinel;\r\n        }\r\n\r\n        if (info.done) {\r\n            // Assign the result of the finished delegate to the temporary\r\n            // variable specified by delegate.resultName (see delegateYield).\r\n            context[delegate.resultName] = info.value;\r\n\r\n            // Resume execution at the desired location (see delegateYield).\r\n            context.next = delegate.nextLoc;\r\n\r\n            // If context.method was \"throw\" but the delegate handled the\r\n            // exception, let the outer generator proceed normally. If\r\n            // context.method was \"next\", forget context.arg since it has been\r\n            // \"consumed\" by the delegate iterator. If context.method was\r\n            // \"return\", allow the original .return call to continue in the\r\n            // outer generator.\r\n            if (context.method !== \"return\") {\r\n                context.method = \"next\";\r\n                context.arg = undefined;\r\n            }\r\n\r\n        } else {\r\n            // Re-yield the result returned by the delegate method.\r\n            return info;\r\n        }\r\n\r\n        // The delegate iterator is finished, so forget it and continue with\r\n        // the outer generator.\r\n        context.delegate = null;\r\n        return ContinueSentinel;\r\n    }\r\n\r\n    // Define Generator.prototype.{next,throw,return} in terms of the\r\n    // unified ._invoke helper method.\r\n    defineIteratorMethods(Gp);\r\n\r\n    Gp[toStringTagSymbol] = \"Generator\";\r\n\r\n    // A Generator should always return itself as the iterator object when the\r\n    // @@iterator function is called on it. Some browsers' implementations of the\r\n    // iterator prototype chain incorrectly implement this, causing the Generator\r\n    // object to not be returned from this call. This ensures that doesn't happen.\r\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\r\n    Gp[iteratorSymbol] = function() {\r\n        return this;\r\n    };\r\n\r\n    Gp.toString = function() {\r\n        return \"[object Generator]\";\r\n    };\r\n\r\n    function pushTryEntry(locs) {\r\n        const entry = { tryLoc: locs[0] };\r\n\r\n        if (1 in locs) {\r\n            entry.catchLoc = locs[1];\r\n        }\r\n\r\n        if (2 in locs) {\r\n            entry.finallyLoc = locs[2];\r\n            entry.afterLoc = locs[3];\r\n        }\r\n\r\n        this.tryEntries.push(entry);\r\n    }\r\n\r\n    function resetTryEntry(entry) {\r\n        const record = entry.completion || {};\r\n        record.type = \"normal\";\r\n        delete record.arg;\r\n        entry.completion = record;\r\n    }\r\n\r\n    function Context(tryLocsList) {\r\n        // The root entry object (effectively a try statement without a catch\r\n        // or a finally block) gives us a place to store values thrown from\r\n        // locations where there is no enclosing try statement.\r\n        this.tryEntries = [{ tryLoc: \"root\" }];\r\n        tryLocsList.forEach(pushTryEntry, this);\r\n        this.reset(true);\r\n    }\r\n\r\n    exports.keys = function(object) {\r\n        const keys = [];\r\n        for (const key in object) {\r\n            keys.push(key);\r\n        }\r\n        keys.reverse();\r\n\r\n        // Rather than returning an object with a next method, we keep\r\n        // things simple and return the next function itself.\r\n        return function next() {\r\n            while (keys.length) {\r\n                const key = keys.pop();\r\n                if (key in object) {\r\n                    next.value = key;\r\n                    next.done = false;\r\n                    return next;\r\n                }\r\n            }\r\n\r\n            // To avoid creating an additional object, we just hang the .value\r\n            // and .done properties off the next function object itself. This\r\n            // also ensures that the minifier will not anonymize the function.\r\n            next.done = true;\r\n            return next;\r\n        };\r\n    };\r\n\r\n    function values(iterable) {\r\n        if (iterable) {\r\n            const iteratorMethod = iterable[iteratorSymbol];\r\n            if (iteratorMethod) {\r\n                return iteratorMethod.call(iterable);\r\n            }\r\n\r\n            if (typeof iterable.next === \"function\") {\r\n                return iterable;\r\n            }\r\n\r\n            if (!isNaN(iterable.length)) {\r\n                let i = -1, next = function next() {\r\n                    while (++i < iterable.length) {\r\n                        if (hasOwn.call(iterable, i)) {\r\n                            next.value = iterable[i];\r\n                            next.done = false;\r\n                            return next;\r\n                        }\r\n                    }\r\n\r\n                    next.value = undefined;\r\n                    next.done = true;\r\n\r\n                    return next;\r\n                };\r\n\r\n                return next.next = next;\r\n            }\r\n        }\r\n\r\n        // Return an iterator with no values.\r\n        return { next: doneResult };\r\n    }\r\n    exports.values = values;\r\n\r\n    function doneResult() {\r\n        return { value: undefined, done: true };\r\n    }\r\n\r\n    Context.prototype = {\r\n        constructor: Context,\r\n\r\n        reset: function(skipTempReset) {\r\n            this.prev = 0;\r\n            this.next = 0;\r\n            // Resetting context._sent for legacy support of Babel's\r\n            // function.sent implementation.\r\n            this.sent = this._sent = undefined;\r\n            this.done = false;\r\n            this.delegate = null;\r\n\r\n            this.method = \"next\";\r\n            this.arg = undefined;\r\n\r\n            this.tryEntries.forEach(resetTryEntry);\r\n\r\n            if (!skipTempReset) {\r\n                for (const name in this) {\r\n                    // Not sure about the optimal order of these conditions:\r\n                    if (name.charAt(0) === \"t\" &&\r\n                        hasOwn.call(this, name) &&\r\n                        !isNaN(+name.slice(1))) {\r\n                        this[name] = undefined;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        stop: function() {\r\n            this.done = true;\r\n\r\n            const rootEntry = this.tryEntries[0];\r\n            const rootRecord = rootEntry.completion;\r\n            if (rootRecord.type === \"throw\") {\r\n                throw rootRecord.arg;\r\n            }\r\n\r\n            return this.rval;\r\n        },\r\n\r\n        dispatchException: function(exception) {\r\n            if (this.done) {\r\n                throw exception;\r\n            }\r\n\r\n            const context = this;\r\n            function handle(loc, caught) {\r\n                record.type = \"throw\";\r\n                record.arg = exception;\r\n                context.next = loc;\r\n\r\n                if (caught) {\r\n                    // If the dispatched exception was caught by a catch block,\r\n                    // then let that catch block handle the exception normally.\r\n                    context.method = \"next\";\r\n                    context.arg = undefined;\r\n                }\r\n\r\n                return !! caught;\r\n            }\r\n\r\n            for (let i = this.tryEntries.length - 1; i >= 0; --i) {\r\n                const entry = this.tryEntries[i];\r\n                var record = entry.completion;\r\n\r\n                if (entry.tryLoc === \"root\") {\r\n                    // Exception thrown outside of any try block that could handle\r\n                    // it, so set the completion value of the entire function to\r\n                    // throw the exception.\r\n                    return handle(\"end\");\r\n                }\r\n\r\n                if (entry.tryLoc <= this.prev) {\r\n                    const hasCatch = hasOwn.call(entry, \"catchLoc\");\r\n                    const hasFinally = hasOwn.call(entry, \"finallyLoc\");\r\n\r\n                    if (hasCatch && hasFinally) {\r\n                        if (this.prev < entry.catchLoc) {\r\n                            return handle(entry.catchLoc, true);\r\n                        } else if (this.prev < entry.finallyLoc) {\r\n                            return handle(entry.finallyLoc);\r\n                        }\r\n\r\n                    } else if (hasCatch) {\r\n                        if (this.prev < entry.catchLoc) {\r\n                            return handle(entry.catchLoc, true);\r\n                        }\r\n\r\n                    } else if (hasFinally) {\r\n                        if (this.prev < entry.finallyLoc) {\r\n                            return handle(entry.finallyLoc);\r\n                        }\r\n\r\n                    } else {\r\n                        throw new Error(\"try statement without catch or finally\");\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        abrupt: function(type, arg) {\r\n            for (let i = this.tryEntries.length - 1; i >= 0; --i) {\r\n                const entry = this.tryEntries[i];\r\n                if (entry.tryLoc <= this.prev &&\r\n                    hasOwn.call(entry, \"finallyLoc\") &&\r\n                    this.prev < entry.finallyLoc) {\r\n                    var finallyEntry = entry;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (finallyEntry &&\r\n                (type === \"break\" ||\r\n                    type === \"continue\") &&\r\n                finallyEntry.tryLoc <= arg &&\r\n                arg <= finallyEntry.finallyLoc) {\r\n                // Ignore the finally entry if control is not jumping to a\r\n                // location outside the try/catch block.\r\n                finallyEntry = null;\r\n            }\r\n\r\n            const record = finallyEntry ? finallyEntry.completion : {};\r\n            record.type = type;\r\n            record.arg = arg;\r\n\r\n            if (finallyEntry) {\r\n                this.method = \"next\";\r\n                this.next = finallyEntry.finallyLoc;\r\n                return ContinueSentinel;\r\n            }\r\n\r\n            return this.complete(record);\r\n        },\r\n\r\n        complete: function(record, afterLoc) {\r\n            if (record.type === \"throw\") {\r\n                throw record.arg;\r\n            }\r\n\r\n            if (record.type === \"break\" ||\r\n                record.type === \"continue\") {\r\n                this.next = record.arg;\r\n            } else if (record.type === \"return\") {\r\n                this.rval = this.arg = record.arg;\r\n                this.method = \"return\";\r\n                this.next = \"end\";\r\n            } else if (record.type === \"normal\" && afterLoc) {\r\n                this.next = afterLoc;\r\n            }\r\n\r\n            return ContinueSentinel;\r\n        },\r\n\r\n        finish: function(finallyLoc) {\r\n            for (let i = this.tryEntries.length - 1; i >= 0; --i) {\r\n                const entry = this.tryEntries[i];\r\n                if (entry.finallyLoc === finallyLoc) {\r\n                    this.complete(entry.completion, entry.afterLoc);\r\n                    resetTryEntry(entry);\r\n                    return ContinueSentinel;\r\n                }\r\n            }\r\n        },\r\n\r\n        \"catch\": function(tryLoc) {\r\n            for (let i = this.tryEntries.length - 1; i >= 0; --i) {\r\n                const entry = this.tryEntries[i];\r\n                if (entry.tryLoc === tryLoc) {\r\n                    const record = entry.completion;\r\n                    if (record.type === \"throw\") {\r\n                        var thrown = record.arg;\r\n                        resetTryEntry(entry);\r\n                    }\r\n                    return thrown;\r\n                }\r\n            }\r\n\r\n            // The context.catch method must only be called with a location\r\n            // argument that corresponds to a known catch block.\r\n            throw new Error(\"illegal catch attempt\");\r\n        },\r\n\r\n        delegateYield: function(iterable, resultName, nextLoc) {\r\n            this.delegate = {\r\n                iterator: values(iterable),\r\n                resultName: resultName,\r\n                nextLoc: nextLoc\r\n            };\r\n\r\n            if (this.method === \"next\") {\r\n                // Deliberately forget the last sent value so that we don't\r\n                // accidentally pass it on to the delegate.\r\n                this.arg = undefined;\r\n            }\r\n\r\n            return ContinueSentinel;\r\n        }\r\n    };\r\n\r\n    // Regardless of whether this script is executing as a CommonJS module\r\n    // or not, return the runtime object so that we can declare the variable\r\n    // regeneratorRuntime in the outer scope, which allows this module to be\r\n    // injected easily by `bin/regenerator --include-runtime script.js`.\r\n    return exports;\r\n\r\n}(\r\n    // If this script is executing as a CommonJS module, use module.exports\r\n    // as the regeneratorRuntime namespace. Otherwise create a new empty\r\n    // object. Either way, the resulting object will be used to initialize\r\n    // the regeneratorRuntime variable at the top of this file.\r\n    typeof module === \"object\" ? module.exports : {}\r\n));"],"file":"runtime.js"}