{"version":3,"names":[],"mappings":"","sources":["bootbox.min.js"],"sourcesContent":["/*! @preserve\n * bootbox.js\n * version: 5.4.0\n * author: Nick Payne <nick@kurai.co.uk>\n * license: MIT\n * http://bootboxjs.com/\n */\n(function (root, factory) {\n  'use strict';\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['jquery'], factory);\n  } else if (typeof exports === 'object') {\n    // Node, CommonJS-like\n    module.exports = factory(require('jquery'));\n  } else {\n    // Browser globals (root is window)\n    root.bootbox = factory(root.jQuery);\n  }\n}(this, function init($, undefined) {\n  'use strict';\n\n  //  Polyfills Object.keys, if necessary.\n  //  @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n  if (!Object.keys) {\n    Object.keys = (function () {\n      var hasOwnProperty = Object.prototype.hasOwnProperty,\n        hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),\n        dontEnums = [\n          'toString',\n          'toLocaleString',\n          'valueOf',\n          'hasOwnProperty',\n          'isPrototypeOf',\n          'propertyIsEnumerable',\n          'constructor'\n        ],\n        dontEnumsLength = dontEnums.length;\n\n      return function (obj) {\n        if (typeof obj !== 'function' && (typeof obj !== 'object' || obj === null)) {\n          throw new TypeError('Object.keys called on non-object');\n        }\n\n        var result = [], prop, i;\n\n        for (prop in obj) {\n          if (hasOwnProperty.call(obj, prop)) {\n            result.push(prop);\n          }\n        }\n\n        if (hasDontEnumBug) {\n          for (i = 0; i < dontEnumsLength; i++) {\n            if (hasOwnProperty.call(obj, dontEnums[i])) {\n              result.push(dontEnums[i]);\n            }\n          }\n        }\n\n        return result;\n      };\n    }());\n  }\n\n  var exports = {};\n\n  var VERSION = '5.0.0';\n  exports.VERSION = VERSION;\n\n  var locales = {\n      ar : {\n        OK      : 'موافق',\n        CANCEL  : 'الغاء',\n        CONFIRM : 'تأكيد'\n      },\n      bg_BG : {\n        OK      : 'Ок',\n        CANCEL  : 'Отказ',\n        CONFIRM : 'Потвърждавам'\n      },\n      br : {\n        OK      : 'OK',\n        CANCEL  : 'Cancelar',\n        CONFIRM : 'Sim'\n      },\n      cs : {\n        OK      : 'OK',\n        CANCEL  : 'Zrušit',\n        CONFIRM : 'Potvrdit'\n      },\n      da : {\n        OK      : 'OK',\n        CANCEL  : 'Annuller',\n        CONFIRM : 'Accepter'\n      },\n      de : {\n        OK      : 'OK',\n        CANCEL  : 'Abbrechen',\n        CONFIRM : 'Akzeptieren'\n      },\n      el : {\n        OK      : 'Εντάξει',\n        CANCEL  : 'Ακύρωση',\n        CONFIRM : 'Επιβεβαίωση'\n      },\n      en : {\n        OK      : 'OK',\n        CANCEL  : 'Cancel',\n        CONFIRM : 'OK'\n      },\n      es : {\n        OK      : 'OK',\n        CANCEL  : 'Cancelar',\n        CONFIRM : 'Aceptar'\n      },\n      eu : {\n        OK      : 'OK',\n        CANCEL  : 'Ezeztatu',\n        CONFIRM : 'Onartu'\n      },\n      et : {\n        OK      : 'OK',\n        CANCEL  : 'Katkesta',\n        CONFIRM : 'OK'\n      },\n      fa : {\n        OK      : 'قبول',\n        CANCEL  : 'لغو',\n        CONFIRM : 'تایید'\n      },\n      fi : {\n        OK      : 'OK',\n        CANCEL  : 'Peruuta',\n        CONFIRM : 'OK'\n      },\n      fr : {\n        OK      : 'OK',\n        CANCEL  : 'Annuler',\n        CONFIRM : 'Confirmer'\n      },\n      he : {\n        OK      : 'אישור',\n        CANCEL  : 'ביטול',\n        CONFIRM : 'אישור'\n      },\n      hu : {\n        OK      : 'OK',\n        CANCEL  : 'Mégsem',\n        CONFIRM : 'Megerősít'\n      },\n      hr : {\n        OK      : 'OK',\n        CANCEL  : 'Odustani',\n        CONFIRM : 'Potvrdi'\n      },\n      id : {\n        OK      : 'OK',\n        CANCEL  : 'Batal',\n        CONFIRM : 'OK'\n      },\n      it : {\n        OK      : 'OK',\n        CANCEL  : 'Annulla',\n        CONFIRM : 'Conferma'\n      },\n      ja : {\n        OK      : 'OK',\n        CANCEL  : 'キャンセル',\n        CONFIRM : '確認'\n      },\n      ka : {\n        OK: 'OK',\n        CANCEL: 'გაუქმება',\n        CONFIRM: 'დადასტურება'\n      },\n      ko : {\n        OK: 'OK',\n        CANCEL: '취소',\n        CONFIRM: '확인'\n      },\n      lt : {\n        OK      : 'Gerai',\n        CANCEL  : 'Atšaukti',\n        CONFIRM : 'Patvirtinti'\n      },\n      lv : {\n        OK      : 'Labi',\n        CANCEL  : 'Atcelt',\n        CONFIRM : 'Apstiprināt'\n      },\n      nl : {\n        OK      : 'OK',\n        CANCEL  : 'Annuleren',\n        CONFIRM : 'Accepteren'\n      },\n      no : {\n        OK      : 'OK',\n        CANCEL  : 'Avbryt',\n        CONFIRM : 'OK'\n      },\n      pl : {\n        OK      : 'OK',\n        CANCEL  : 'Anuluj',\n        CONFIRM : 'Potwierdź'\n      },\n      pt : {\n        OK      : 'OK',\n        CANCEL  : 'Cancelar',\n        CONFIRM : 'Confirmar'\n      },\n      ru : {\n        OK      : 'OK',\n        CANCEL  : 'Отмена',\n        CONFIRM : 'Применить'\n      },\n      sk : {\n        OK      : 'OK',\n        CANCEL  : 'Zrušiť',\n        CONFIRM : 'Potvrdiť'\n      },\n      sl : {\n        OK      : 'OK',\n        CANCEL  : 'Prekliči',\n        CONFIRM : 'Potrdi'\n      },\n      sq : {\n        OK      : 'OK',\n        CANCEL  : 'Anulo',\n        CONFIRM : 'Prano'\n      },\n      sv : {\n        OK      : 'OK',\n        CANCEL  : 'Avbryt',\n        CONFIRM : 'OK'\n      },\n      sw: {\n        OK      : 'Sawa',\n        CANCEL  : 'Ghairi',\n        CONFIRM: 'Thibitisha'\n      },\n      ta:{\n        OK      : 'சரி',\n        CANCEL  : 'ரத்து செய்',\n        CONFIRM : 'உறுதி செய்'\n      },\n      th : {\n        OK      : 'ตกลง',\n        CANCEL  : 'ยกเลิก',\n        CONFIRM : 'ยืนยัน'\n      },\n      tr : {\n        OK      : 'Tamam',\n        CANCEL  : 'İptal',\n        CONFIRM : 'Onayla'\n      },\n      uk : {\n        OK      : 'OK',\n        CANCEL  : 'Відміна',\n        CONFIRM : 'Прийняти'\n      },\n      zh_CN : {\n        OK      : 'OK',\n        CANCEL  : '取消',\n        CONFIRM : '确认'\n      },\n      zh_TW : {\n        OK      : 'OK',\n        CANCEL  : '取消',\n        CONFIRM : '確認'\n      }\n  };\n\n  var templates = {\n    dialog:\n    '<div class=\"bootbox modal\" tabindex=\"-1\" role=\"dialog\" aria-hidden=\"true\">' +\n    '<div class=\"modal-dialog\">' +\n    '<div class=\"modal-content\">' +\n    '<div class=\"modal-body\"><div class=\"bootbox-body\"></div></div>' +\n    '</div>' +\n    '</div>' +\n    '</div>',\n    header:\n    '<div class=\"modal-header\">' +\n    '<h5 class=\"modal-title\"></h5>' +\n    '</div>',\n    footer:\n    '<div class=\"modal-footer\"></div>',\n    closeButton:\n    '<button type=\"button\" class=\"bootbox-close-button close\" aria-hidden=\"true\">&times;</button>',\n    form:\n    '<form class=\"bootbox-form\"></form>',\n    button:\n    '<button type=\"button\" class=\"btn\"></button>',\n    option:\n    '<option></option>',\n    promptMessage:\n    '<div class=\"bootbox-prompt-message\"></div>',\n    inputs: {\n      text:\n      '<input class=\"bootbox-input bootbox-input-text form-control\" autocomplete=\"off\" type=\"text\" />',\n      textarea:\n      '<textarea class=\"bootbox-input bootbox-input-textarea form-control\"></textarea>',\n      email:\n      '<input class=\"bootbox-input bootbox-input-email form-control\" autocomplete=\"off\" type=\"email\" />',\n      select:\n      '<select class=\"bootbox-input bootbox-input-select form-control\"></select>',\n      checkbox:\n      '<div class=\"form-check checkbox\"><label class=\"form-check-label\"><input class=\"form-check-input bootbox-input bootbox-input-checkbox\" type=\"checkbox\" /></label></div>',\n      radio:\n      '<div class=\"form-check radio\"><label class=\"form-check-label\"><input class=\"form-check-input bootbox-input bootbox-input-radio\" type=\"radio\" name=\"bootbox-radio\" /></label></div>',\n      date:\n      '<input class=\"bootbox-input bootbox-input-date form-control\" autocomplete=\"off\" type=\"date\" />',\n      time:\n      '<input class=\"bootbox-input bootbox-input-time form-control\" autocomplete=\"off\" type=\"time\" />',\n      number:\n      '<input class=\"bootbox-input bootbox-input-number form-control\" autocomplete=\"off\" type=\"number\" />',\n      password:\n      '<input class=\"bootbox-input bootbox-input-password form-control\" autocomplete=\"off\" type=\"password\" />',\n      range:\n      '<input class=\"bootbox-input bootbox-input-range form-control-range\" autocomplete=\"off\" type=\"range\" />'\n    }\n  };\n\n\n  var defaults = {\n    // default language\n    locale: 'en',\n    // show backdrop or not. Default to static so user has to interact with dialog\n    backdrop: 'static',\n    // animate the modal in/out\n    animate: true,\n    // additional class string applied to the top level dialog\n    className: null,\n    // whether or not to include a close button\n    closeButton: true,\n    // show the dialog immediately by default\n    show: true,\n    // dialog container\n    container: 'body',\n    // default value (used by the prompt helper)\n    value: '',\n    // default input type (used by the prompt helper)\n    inputType: 'text',\n    // switch button order from cancel/confirm (default) to confirm/cancel\n    swapButtonOrder: false,\n    // center modal vertically in page\n    centerVertical: false,\n    // Append \"multiple\" property to the select when using the \"prompt\" helper\n    multiple: false,\n    // Automatically scroll modal content when height exceeds viewport height\n    scrollable: false\n  };\n\n\n  // PUBLIC FUNCTIONS\n  // *************************************************************************************************************\n\n  // Return all currently registered locales, or a specific locale if \"name\" is defined\n  exports.locales = function (name) {\n    return name ? locales[name] : locales;\n  };\n\n\n  // Register localized strings for the OK, CONFIRM, and CANCEL buttons\n  exports.addLocale = function (name, values) {\n    $.each(['OK', 'CANCEL', 'CONFIRM'], function (_, v) {\n      if (!values[v]) {\n        throw new Error('Please supply a translation for \"' + v + '\"');\n      }\n    });\n\n    locales[name] = {\n      OK: values.OK,\n      CANCEL: values.CANCEL,\n      CONFIRM: values.CONFIRM\n    };\n\n    return exports;\n  };\n\n\n  // Remove a previously-registered locale\n  exports.removeLocale = function (name) {\n    if (name !== 'en') {\n      delete locales[name];\n    }\n    else {\n      throw new Error('\"en\" is used as the default and fallback locale and cannot be removed.');\n    }\n\n    return exports;\n  };\n\n\n  // Set the default locale\n  exports.setLocale = function (name) {\n    return exports.setDefaults('locale', name);\n  };\n\n\n  // Override default value(s) of Bootbox.\n  exports.setDefaults = function () {\n    var values = {};\n\n    if (arguments.length === 2) {\n      // allow passing of single key/value...\n      values[arguments[0]] = arguments[1];\n    } else {\n      // ... and as an object too\n      values = arguments[0];\n    }\n\n    $.extend(defaults, values);\n\n    return exports;\n  };\n\n\n  // Hides all currently active Bootbox modals\n  exports.hideAll = function () {\n    $('.bootbox').modal('hide');\n\n    return exports;\n  };\n\n\n  // Allows the base init() function to be overridden\n  exports.init = function (_$) {\n    return init(_$ || $);\n  };\n\n\n  // CORE HELPER FUNCTIONS\n  // *************************************************************************************************************\n\n  // Core dialog function\n  exports.dialog = function (options) {\n    if ($.fn.modal === undefined) {\n      throw new Error(\n        '\"$.fn.modal\" is not defined; please double check you have included ' +\n        'the Bootstrap JavaScript library. See http://getbootstrap.com/javascript/ ' +\n        'for more details.'\n      );\n    }\n\n    options = sanitize(options);\n\n    if ($.fn.modal.Constructor.VERSION) {\n      options.fullBootstrapVersion = $.fn.modal.Constructor.VERSION;\n      var i = options.fullBootstrapVersion.indexOf('.');\n      options.bootstrap = options.fullBootstrapVersion.substring(0, i);\n    }\n    else {\n      // Assuming version 2.3.2, as that was the last \"supported\" 2.x version\n      options.bootstrap = '2';\n      options.fullBootstrapVersion = '2.3.2';\n      console.warn('Bootbox will *mostly* work with Bootstrap 2, but we do not officially support it. Please upgrade, if possible.');\n    }\n\n    var dialog = $(templates.dialog);\n    var innerDialog = dialog.find('.modal-dialog');\n    var body = dialog.find('.modal-body');\n    var header = $(templates.header);\n    var footer = $(templates.footer);\n    var buttons = options.buttons;\n\n    var callbacks = {\n      onEscape: options.onEscape\n    };\n\n    body.find('.bootbox-body').html(options.message);\n\n    // Only attempt to create buttons if at least one has \n    // been defined in the options object\n    if (getKeyLength(options.buttons) > 0) {\n      each(buttons, function (key, b) {\n        var button = $(templates.button);\n        button.data('bb-handler', key);\n        button.addClass(b.className);\n\n        switch (key) {\n          case 'ok':\n          case 'confirm':\n            button.addClass('bootbox-accept');\n            break;\n\n          case 'cancel':\n            button.addClass('bootbox-cancel');\n            break;\n        }\n\n        button.html(b.label);\n        footer.append(button);\n\n        callbacks[key] = b.callback;\n      });\n\n      body.after(footer);\n    }\n\n    if (options.animate === true) {\n      dialog.addClass('fade');\n    }\n\n    if (options.className) {\n      dialog.addClass(options.className);\n    }\n\n    if (options.size) {\n      // Requires Bootstrap 3.1.0 or higher\n      if (options.fullBootstrapVersion.substring(0, 3) < '3.1') {\n        console.warn('\"size\" requires Bootstrap 3.1.0 or higher. You appear to be using ' + options.fullBootstrapVersion + '. Please upgrade to use this option.');\n      }\n\n      switch (options.size) {\n        case 'small':\n        case 'sm':\n          innerDialog.addClass('modal-sm');\n          break;\n\n        case 'large':\n        case 'lg':\n          innerDialog.addClass('modal-lg');\n          break;\n\n        case 'extra-large':\n        case 'xl':\n          innerDialog.addClass('modal-xl');\n\n          // Requires Bootstrap 4.2.0 or higher\n          if (options.fullBootstrapVersion.substring(0, 3) < '4.2') {\n            console.warn('Using size \"xl\"/\"extra-large\" requires Bootstrap 4.2.0 or higher. You appear to be using ' + options.fullBootstrapVersion + '. Please upgrade to use this option.');\n          }\n          break;\n      }\n    }\n\n    if (options.scrollable) {\n      innerDialog.addClass('modal-dialog-scrollable');\n\n      // Requires Bootstrap 4.3.0 or higher\n      if (options.fullBootstrapVersion.substring(0, 3) < '4.3') {\n        console.warn('Using \"scrollable\" requires Bootstrap 4.3.0 or higher. You appear to be using ' + options.fullBootstrapVersion + '. Please upgrade to use this option.');\n      }\n    }\n\n    if (options.title) {\n      body.before(header);\n      dialog.find('.modal-title').html(options.title);\n    }\n\n    if (options.closeButton) {\n      var closeButton = $(templates.closeButton);\n\n      if (options.title) {\n        if (options.bootstrap > 3) {\n          dialog.find('.modal-header').append(closeButton);\n        }\n        else {\n          dialog.find('.modal-header').prepend(closeButton);\n        }\n      } else {\n        closeButton.prependTo(body);\n      }\n    }\n\n    if (options.centerVertical) {\n      innerDialog.addClass('modal-dialog-centered');\n\n      // Requires Bootstrap 4.0.0-beta.3 or higher\n      if (options.fullBootstrapVersion < '4.0.0') {\n        console.warn('\"centerVertical\" requires Bootstrap 4.0.0-beta.3 or higher. You appear to be using ' + options.fullBootstrapVersion + '. Please upgrade to use this option.');\n      }\n    }\n\n    // Bootstrap event listeners; these handle extra\n    // setup & teardown required after the underlying\n    // modal has performed certain actions.\n\n    // make sure we unbind any listeners once the dialog has definitively been dismissed\n    dialog.one('hide.bs.modal', { dialog: dialog }, unbindModal);\n\n    if (options.onHide) {\n      if ($.isFunction(options.onHide)) {\n        dialog.on('hide.bs.modal', options.onHide);\n      }\n      else {\n        throw new Error('Argument supplied to \"onHide\" must be a function');\n      }\n    }\n\n    dialog.one('hidden.bs.modal', { dialog: dialog }, destroyModal);\n\n    if (options.onHidden) {\n      if ($.isFunction(options.onHidden)) {\n        dialog.on('hidden.bs.modal', options.onHidden);\n      }\n      else {\n        throw new Error('Argument supplied to \"onHidden\" must be a function');\n      }\n    }\n\n    if (options.onShow) {\n      if ($.isFunction(options.onShow)) {\n        dialog.on('show.bs.modal', options.onShow);\n      }\n      else {\n        throw new Error('Argument supplied to \"onShow\" must be a function');\n      }\n    }\n\n    dialog.one('shown.bs.modal', { dialog: dialog }, focusPrimaryButton);\n\n    if (options.onShown) {\n      if ($.isFunction(options.onShown)) {\n        dialog.on('shown.bs.modal', options.onShown);\n      }\n      else {\n        throw new Error('Argument supplied to \"onShown\" must be a function');\n      }\n    }\n\n    // Bootbox event listeners; used to decouple some\n    // behaviours from their respective triggers\n\n    if (options.backdrop !== 'static') {\n      // A boolean true/false according to the Bootstrap docs\n      // should show a dialog the user can dismiss by clicking on\n      // the background.\n      // We always only ever pass static/false to the actual\n      // $.modal function because with \"true\" we can't trap\n      // this event (the .modal-backdrop swallows it)\n      // However, we still want to sort-of respect true\n      // and invoke the escape mechanism instead\n      dialog.on('click.dismiss.bs.modal', function (e) {\n        // @NOTE: the target varies in >= 3.3.x releases since the modal backdrop\n        // moved *inside* the outer dialog rather than *alongside* it\n        if (dialog.children('.modal-backdrop').length) {\n          e.currentTarget = dialog.children('.modal-backdrop').get(0);\n        }\n\n        if (e.target !== e.currentTarget) {\n          return;\n        }\n\n        dialog.trigger('escape.close.bb');\n      });\n    }\n\n    dialog.on('escape.close.bb', function (e) {\n      // the if statement looks redundant but it isn't; without it\n      // if we *didn't* have an onEscape handler then processCallback\n      // would automatically dismiss the dialog\n      if (callbacks.onEscape) {\n        processCallback(e, dialog, callbacks.onEscape);\n      }\n    });\n\n\n    dialog.on('click', '.modal-footer button:not(.disabled)', function (e) {\n      var callbackKey = $(this).data('bb-handler');\n\n      if (callbackKey !== undefined) {\n        // Only process callbacks for buttons we recognize:\n        processCallback(e, dialog, callbacks[callbackKey]);\n      }\n    });\n\n    dialog.on('click', '.bootbox-close-button', function (e) {\n      // onEscape might be falsy but that's fine; the fact is\n      // if the user has managed to click the close button we\n      // have to close the dialog, callback or not\n      processCallback(e, dialog, callbacks.onEscape);\n    });\n\n    dialog.on('keyup', function (e) {\n      if (e.which === 27) {\n        dialog.trigger('escape.close.bb');\n      }\n    });\n\n    // the remainder of this method simply deals with adding our\n    // dialog element to the DOM, augmenting it with Bootstrap's modal\n    // functionality and then giving the resulting object back\n    // to our caller\n\n    $(options.container).append(dialog);\n\n    dialog.modal({\n      backdrop: options.backdrop ? 'static' : false,\n      keyboard: false,\n      show: false\n    });\n\n    if (options.show) {\n      dialog.modal('show');\n    }\n\n    return dialog;\n  };\n\n\n  // Helper function to simulate the native alert() behavior. **NOTE**: This is non-blocking, so any\n  // code that must happen after the alert is dismissed should be placed within the callback function \n  // for this alert.\n  exports.alert = function () {\n    var options;\n\n    options = mergeDialogOptions('alert', ['ok'], ['message', 'callback'], arguments);\n\n    // @TODO: can this move inside exports.dialog when we're iterating over each\n    // button and checking its button.callback value instead?\n    if (options.callback && !$.isFunction(options.callback)) {\n      throw new Error('alert requires the \"callback\" property to be a function when provided');\n    }\n\n    // override the ok and escape callback to make sure they just invoke\n    // the single user-supplied one (if provided)\n    options.buttons.ok.callback = options.onEscape = function () {\n      if ($.isFunction(options.callback)) {\n        return options.callback.call(this);\n      }\n\n      return true;\n    };\n\n    return exports.dialog(options);\n  };\n\n\n  // Helper function to simulate the native confirm() behavior. **NOTE**: This is non-blocking, so any\n  // code that must happen after the confirm is dismissed should be placed within the callback function \n  // for this confirm.\n  exports.confirm = function () {\n    var options;\n\n    options = mergeDialogOptions('confirm', ['cancel', 'confirm'], ['message', 'callback'], arguments);\n\n    // confirm specific validation; they don't make sense without a callback so make\n    // sure it's present\n    if (!$.isFunction(options.callback)) {\n      throw new Error('confirm requires a callback');\n    }\n\n    // overrides; undo anything the user tried to set they shouldn't have\n    options.buttons.cancel.callback = options.onEscape = function () {\n      return options.callback.call(this, false);\n    };\n\n    options.buttons.confirm.callback = function () {\n      return options.callback.call(this, true);\n    };\n\n    return exports.dialog(options);\n  };\n\n\n  // Helper function to simulate the native prompt() behavior. **NOTE**: This is non-blocking, so any\n  // code that must happen after the prompt is dismissed should be placed within the callback function \n  // for this prompt.\n  exports.prompt = function () {\n    var options;\n    var promptDialog;\n    var form;\n    var input;\n    var shouldShow;\n    var inputOptions;\n\n    // we have to create our form first otherwise\n    // its value is undefined when gearing up our options\n    // @TODO this could be solved by allowing message to\n    // be a function instead...\n    form = $(templates.form);\n\n    // prompt defaults are more complex than others in that\n    // users can override more defaults\n    options = mergeDialogOptions('prompt', ['cancel', 'confirm'], ['title', 'callback'], arguments);\n\n    if (!options.value) {\n      options.value = defaults.value;\n    }\n\n    if (!options.inputType) {\n      options.inputType = defaults.inputType;\n    }\n\n    // capture the user's show value; we always set this to false before\n    // spawning the dialog to give us a chance to attach some handlers to\n    // it, but we need to make sure we respect a preference not to show it\n    shouldShow = (options.show === undefined) ? defaults.show : options.show;\n\n    // This is required prior to calling the dialog builder below - we need to \n    // add an event handler just before the prompt is shown\n    options.show = false;\n\n    // Handles the 'cancel' action\n    options.buttons.cancel.callback = options.onEscape = function () {\n      return options.callback.call(this, null);\n    };\n\n    // Prompt submitted - extract the prompt value. This requires a bit of work, \n    // given the different input types available.\n    options.buttons.confirm.callback = function () {\n      var value;\n\n      if (options.inputType === 'checkbox') {\n        value = input.find('input:checked').map(function () {\n          return $(this).val();\n        }).get();\n      } else if (options.inputType === 'radio') {\n        value = input.find('input:checked').val();\n      }\n      else {\n        if (input[0].checkValidity && !input[0].checkValidity()) {\n          // prevents button callback from being called\n          return false;\n        } else {\n          if (options.inputType === 'select' && options.multiple === true) {\n            value = input.find('option:selected').map(function () {\n              return $(this).val();\n            }).get();\n          }\n          else {\n            value = input.val();\n          }\n        }\n      }\n\n      return options.callback.call(this, value);\n    };\n\n    // prompt-specific validation\n    if (!options.title) {\n      throw new Error('prompt requires a title');\n    }\n\n    if (!$.isFunction(options.callback)) {\n      throw new Error('prompt requires a callback');\n    }\n\n    if (!templates.inputs[options.inputType]) {\n      throw new Error('Invalid prompt type');\n    }\n\n    // create the input based on the supplied type\n    input = $(templates.inputs[options.inputType]);\n\n    switch (options.inputType) {\n      case 'text':\n      case 'textarea':\n      case 'email':\n      case 'password':\n        input.val(options.value);\n\n        if (options.placeholder) {\n          input.attr('placeholder', options.placeholder);\n        }\n\n        if (options.pattern) {\n          input.attr('pattern', options.pattern);\n        }\n\n        if (options.maxlength) {\n          input.attr('maxlength', options.maxlength);\n        }\n\n        if (options.required) {\n          input.prop({ 'required': true });\n        }\n\n        if (options.rows && !isNaN(parseInt(options.rows))) {\n          if (options.inputType === 'textarea') {\n            input.attr({ 'rows': options.rows });\n          }\n        }\n\n        break;\n\n\n      case 'date':\n      case 'time':\n      case 'number':\n      case 'range':\n        input.val(options.value);\n\n        if (options.placeholder) {\n          input.attr('placeholder', options.placeholder);\n        }\n\n        if (options.pattern) {\n          input.attr('pattern', options.pattern);\n        }\n\n        if (options.required) {\n          input.prop({ 'required': true });\n        }\n\n        // These input types have extra attributes which affect their input validation.\n        // Warning: For most browsers, date inputs are buggy in their implementation of 'step', so \n        // this attribute will have no effect. Therefore, we don't set the attribute for date inputs.\n        // @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date#Setting_maximum_and_minimum_dates\n        if (options.inputType !== 'date') {\n          if (options.step) {\n            if (options.step === 'any' || (!isNaN(options.step) && parseFloat(options.step) > 0)) {\n              input.attr('step', options.step);\n            }\n            else {\n              throw new Error('\"step\" must be a valid positive number or the value \"any\". See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-step for more information.');\n            }\n          }\n        }\n\n        if (minAndMaxAreValid(options.inputType, options.min, options.max)) {\n          if (options.min !== undefined) {\n            input.attr('min', options.min);\n          }\n          if (options.max !== undefined) {\n            input.attr('max', options.max);\n          }\n        }\n\n        break;\n\n\n      case 'select':\n        var groups = {};\n        inputOptions = options.inputOptions || [];\n\n        if (!$.isArray(inputOptions)) {\n          throw new Error('Please pass an array of input options');\n        }\n\n        if (!inputOptions.length) {\n          throw new Error('prompt with \"inputType\" set to \"select\" requires at least one option');\n        }\n\n        // placeholder is not actually a valid attribute for select,\n        // but we'll allow it, assuming it might be used for a plugin\n        if (options.placeholder) {\n          input.attr('placeholder', options.placeholder);\n        }\n\n        if (options.required) {\n          input.prop({ 'required': true });\n        }\n\n        if (options.multiple) {\n          input.prop({ 'multiple': true });\n        }\n\n        each(inputOptions, function (_, option) {\n          // assume the element to attach to is the input...\n          var elem = input;\n\n          if (option.value === undefined || option.text === undefined) {\n            throw new Error('each option needs a \"value\" property and a \"text\" property');\n          }\n\n          // ... but override that element if this option sits in a group\n\n          if (option.group) {\n            // initialise group if necessary\n            if (!groups[option.group]) {\n              groups[option.group] = $('<optgroup />').attr('label', option.group);\n            }\n\n            elem = groups[option.group];\n          }\n\n          var o = $(templates.option);\n          o.attr('value', option.value).text(option.text);\n          elem.append(o);\n        });\n\n        each(groups, function (_, group) {\n          input.append(group);\n        });\n\n        // safe to set a select's value as per a normal input\n        input.val(options.value);\n\n        break;\n\n\n      case 'checkbox':\n        var checkboxValues = $.isArray(options.value) ? options.value : [options.value];\n        inputOptions = options.inputOptions || [];\n\n        if (!inputOptions.length) {\n          throw new Error('prompt with \"inputType\" set to \"checkbox\" requires at least one option');\n        }\n\n        // checkboxes have to nest within a containing element, so\n        // they break the rules a bit and we end up re-assigning\n        // our 'input' element to this container instead\n        input = $('<div class=\"bootbox-checkbox-list\"></div>');\n\n        each(inputOptions, function (_, option) {\n          if (option.value === undefined || option.text === undefined) {\n            throw new Error('each option needs a \"value\" property and a \"text\" property');\n          }\n\n          var checkbox = $(templates.inputs[options.inputType]);\n\n          checkbox.find('input').attr('value', option.value);\n          checkbox.find('label').append('\\n' + option.text);\n\n          // we've ensured values is an array so we can always iterate over it\n          each(checkboxValues, function (_, value) {\n            if (value === option.value) {\n              checkbox.find('input').prop('checked', true);\n            }\n          });\n\n          input.append(checkbox);\n        });\n        break;\n\n\n      case 'radio':\n        // Make sure that value is not an array (only a single radio can ever be checked)\n        if (options.value !== undefined && $.isArray(options.value)) {\n          throw new Error('prompt with \"inputType\" set to \"radio\" requires a single, non-array value for \"value\"');\n        }\n\n        inputOptions = options.inputOptions || [];\n\n        if (!inputOptions.length) {\n          throw new Error('prompt with \"inputType\" set to \"radio\" requires at least one option');\n        }\n\n        // Radiobuttons have to nest within a containing element, so\n        // they break the rules a bit and we end up re-assigning\n        // our 'input' element to this container instead\n        input = $('<div class=\"bootbox-radiobutton-list\"></div>');\n\n        // Radiobuttons should always have an initial checked input checked in a \"group\".\n        // If value is undefined or doesn't match an input option, select the first radiobutton\n        var checkFirstRadio = true;\n\n        each(inputOptions, function (_, option) {\n          if (option.value === undefined || option.text === undefined) {\n            throw new Error('each option needs a \"value\" property and a \"text\" property');\n          }\n\n          var radio = $(templates.inputs[options.inputType]);\n\n          radio.find('input').attr('value', option.value);\n          radio.find('label').append('\\n' + option.text);\n\n          if (options.value !== undefined) {\n            if (option.value === options.value) {\n              radio.find('input').prop('checked', true);\n              checkFirstRadio = false;\n            }\n          }\n\n          input.append(radio);\n        });\n\n        if (checkFirstRadio) {\n          input.find('input[type=\"radio\"]').first().prop('checked', true);\n        }\n        break;\n    }\n\n    // now place it in our form\n    form.append(input);\n\n    form.on('submit', function (e) {\n      e.preventDefault();\n      // Fix for SammyJS (or similar JS routing library) hijacking the form post.\n      e.stopPropagation();\n\n      // @TODO can we actually click *the* button object instead?\n      // e.g. buttons.confirm.click() or similar\n      promptDialog.find('.bootbox-accept').trigger('click');\n    });\n\n    if ($.trim(options.message) !== '') {\n      // Add the form to whatever content the user may have added.\n      var message = $(templates.promptMessage).html(options.message);\n      form.prepend(message);\n      options.message = form;\n    }\n    else {\n      options.message = form;\n    }\n\n    // Generate the dialog\n    promptDialog = exports.dialog(options);\n\n    // clear the existing handler focusing the submit button...\n    promptDialog.off('shown.bs.modal', focusPrimaryButton);\n\n    // ...and replace it with one focusing our input, if possible\n    promptDialog.on('shown.bs.modal', function () {\n      // need the closure here since input isn't\n      // an object otherwise\n      input.focus();\n    });\n\n    if (shouldShow === true) {\n      promptDialog.modal('show');\n    }\n\n    return promptDialog;\n  };\n\n\n  // INTERNAL FUNCTIONS\n  // *************************************************************************************************************\n\n  // Map a flexible set of arguments into a single returned object\n  // If args.length is already one just return it, otherwise\n  // use the properties argument to map the unnamed args to\n  // object properties.\n  // So in the latter case:\n  //  mapArguments([\"foo\", $.noop], [\"message\", \"callback\"])\n  //  -> { message: \"foo\", callback: $.noop }\n  function mapArguments(args, properties) {\n    var argn = args.length;\n    var options = {};\n\n    if (argn < 1 || argn > 2) {\n      throw new Error('Invalid argument length');\n    }\n\n    if (argn === 2 || typeof args[0] === 'string') {\n      options[properties[0]] = args[0];\n      options[properties[1]] = args[1];\n    } else {\n      options = args[0];\n    }\n\n    return options;\n  }\n\n\n  //  Merge a set of default dialog options with user supplied arguments\n  function mergeArguments(defaults, args, properties) {\n    return $.extend(\n      // deep merge\n      true,\n      // ensure the target is an empty, unreferenced object\n      {},\n      // the base options object for this type of dialog (often just buttons)\n      defaults,\n      // args could be an object or array; if it's an array properties will\n      // map it to a proper options object\n      mapArguments(\n        args,\n        properties\n      )\n    );\n  }\n\n\n  //  This entry-level method makes heavy use of composition to take a simple\n  //  range of inputs and return valid options suitable for passing to bootbox.dialog\n  function mergeDialogOptions(className, labels, properties, args) {\n    var locale;\n    if (args && args[0]) {\n      locale = args[0].locale || defaults.locale;\n      var swapButtons = args[0].swapButtonOrder || defaults.swapButtonOrder;\n\n      if (swapButtons) {\n        labels = labels.reverse();\n      }\n    }\n\n    //  build up a base set of dialog properties\n    var baseOptions = {\n      className: 'bootbox-' + className,\n      buttons: createLabels(labels, locale)\n    };\n\n    // Ensure the buttons properties generated, *after* merging\n    // with user args are still valid against the supplied labels\n    return validateButtons(\n      // merge the generated base properties with user supplied arguments\n      mergeArguments(\n        baseOptions,\n        args,\n        // if args.length > 1, properties specify how each arg maps to an object key\n        properties\n      ),\n      labels\n    );\n  }\n\n\n  //  Checks each button object to see if key is valid. \n  //  This function will only be called by the alert, confirm, and prompt helpers. \n  function validateButtons(options, buttons) {\n    var allowedButtons = {};\n    each(buttons, function (key, value) {\n      allowedButtons[value] = true;\n    });\n\n    each(options.buttons, function (key) {\n      if (allowedButtons[key] === undefined) {\n        throw new Error('button key \"' + key + '\" is not allowed (options are ' + buttons.join(' ') + ')');\n      }\n    });\n\n    return options;\n  }\n\n\n\n  //  From a given list of arguments, return a suitable object of button labels.\n  //  All this does is normalise the given labels and translate them where possible.\n  //  e.g. \"ok\", \"confirm\" -> { ok: \"OK\", cancel: \"Annuleren\" }\n  function createLabels(labels, locale) {\n    var buttons = {};\n\n    for (var i = 0, j = labels.length; i < j; i++) {\n      var argument = labels[i];\n      var key = argument.toLowerCase();\n      var value = argument.toUpperCase();\n\n      buttons[key] = {\n        label: getText(value, locale)\n      };\n    }\n\n    return buttons;\n  }\n\n\n\n  //  Get localized text from a locale. Defaults to 'en' locale if no locale \n  //  provided or a non-registered locale is requested\n  function getText(key, locale) {\n    var labels = locales[locale];\n\n    return labels ? labels[key] : locales.en[key];\n  }\n\n\n\n  //  Filter and tidy up any user supplied parameters to this dialog.\n  //  Also looks for any shorthands used and ensures that the options\n  //  which are returned are all normalized properly\n  function sanitize(options) {\n    var buttons;\n    var total;\n\n    if (typeof options !== 'object') {\n      throw new Error('Please supply an object of options');\n    }\n\n    if (!options.message) {\n      throw new Error('\"message\" option must not be null or an empty string.');\n    }\n\n    // make sure any supplied options take precedence over defaults\n    options = $.extend({}, defaults, options);\n\n    // no buttons is still a valid dialog but it's cleaner to always have\n    // a buttons object to iterate over, even if it's empty\n    if (!options.buttons) {\n      options.buttons = {};\n    }\n\n    buttons = options.buttons;\n\n    total = getKeyLength(buttons);\n\n    each(buttons, function (key, button, index) {\n      if ($.isFunction(button)) {\n        // short form, assume value is our callback. Since button\n        // isn't an object it isn't a reference either so re-assign it\n        button = buttons[key] = {\n          callback: button\n        };\n      }\n\n      // before any further checks make sure by now button is the correct type\n      if ($.type(button) !== 'object') {\n        throw new Error('button with key \"' + key + '\" must be an object');\n      }\n\n      if (!button.label) {\n        // the lack of an explicit label means we'll assume the key is good enough\n        button.label = key;\n      }\n\n      if (!button.className) {\n        var isPrimary = false;\n        if (options.swapButtonOrder) {\n          isPrimary = index === 0;\n        }\n        else {\n          isPrimary = index === total - 1;\n        }\n\n        if (total <= 2 && isPrimary) {\n          // always add a primary to the main option in a one or two-button dialog\n          button.className = 'btn-primary';\n        } else {\n          // adding both classes allows us to target both BS3 and BS4 without needing to check the version\n          button.className = 'btn-secondary btn-default';\n        }\n      }\n    });\n\n    return options;\n  }\n\n\n  //  Returns a count of the properties defined on the object\n  function getKeyLength(obj) {\n    return Object.keys(obj).length;\n  }\n\n\n  //  Tiny wrapper function around jQuery.each; just adds index as the third parameter\n  function each(collection, iterator) {\n    var index = 0;\n    $.each(collection, function (key, value) {\n      iterator(key, value, index++);\n    });\n  }\n\n\n  function focusPrimaryButton(e) {\n    e.data.dialog.find('.bootbox-accept').first().trigger('focus');\n  }\n\n\n  function destroyModal(e) {\n    // ensure we don't accidentally intercept hidden events triggered\n    // by children of the current dialog. We shouldn't need to handle this anymore, \n    // now that Bootstrap namespaces its events, but still worth doing.\n    if (e.target === e.data.dialog[0]) {\n      e.data.dialog.remove();\n    }\n  }\n\n\n  function unbindModal(e) {\n    if (e.target === e.data.dialog[0]) {\n      e.data.dialog.off('escape.close.bb');\n      e.data.dialog.off('click');\n    }\n  }\n\n\n  //  Handle the invoked dialog callback\n  function processCallback(e, dialog, callback) {\n    e.stopPropagation();\n    e.preventDefault();\n\n    // by default we assume a callback will get rid of the dialog,\n    // although it is given the opportunity to override this\n\n    // so, if the callback can be invoked and it *explicitly returns false*\n    // then we'll set a flag to keep the dialog active...\n    var preserveDialog = $.isFunction(callback) && callback.call(dialog, e) === false;\n\n    // ... otherwise we'll bin it\n    if (!preserveDialog) {\n      dialog.modal('hide');\n    }\n  }\n\n  // Validate `min` and `max` values based on the current `inputType` value\n  function minAndMaxAreValid(type, min, max) {\n    var result = false;\n    var minValid = true;\n    var maxValid = true;\n\n    if (type === 'date') {\n      if (min !== undefined && !(minValid = dateIsValid(min))) {\n        console.warn('Browsers which natively support the \"date\" input type expect date values to be of the form \"YYYY-MM-DD\" (see ISO-8601 https://www.iso.org/iso-8601-date-and-time-format.html). Bootbox does not enforce this rule, but your min value may not be enforced by this browser.');\n      }\n      else if (max !== undefined && !(maxValid = dateIsValid(max))) {\n        console.warn('Browsers which natively support the \"date\" input type expect date values to be of the form \"YYYY-MM-DD\" (see ISO-8601 https://www.iso.org/iso-8601-date-and-time-format.html). Bootbox does not enforce this rule, but your max value may not be enforced by this browser.');\n      }\n    }\n    else if (type === 'time') {\n      if (min !== undefined && !(minValid = timeIsValid(min))) {\n        throw new Error('\"min\" is not a valid time. See https://www.w3.org/TR/2012/WD-html-markup-20120315/datatypes.html#form.data.time for more information.');\n      }\n      else if (max !== undefined && !(maxValid = timeIsValid(max))) {\n        throw new Error('\"max\" is not a valid time. See https://www.w3.org/TR/2012/WD-html-markup-20120315/datatypes.html#form.data.time for more information.');\n      }\n    }\n    else {\n      if (min !== undefined && isNaN(min)) {\n        minValid = false;\n        throw new Error('\"min\" must be a valid number. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-min for more information.');\n      }\n\n      if (max !== undefined && isNaN(max)) {\n        maxValid = false;\n        throw new Error('\"max\" must be a valid number. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-max for more information.');\n      }\n    }\n\n    if (minValid && maxValid) {\n      if (max <= min) {\n        throw new Error('\"max\" must be greater than \"min\". See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-max for more information.');\n      }\n      else {\n        result = true;\n      }\n    }\n\n    return result;\n  }\n\n  function timeIsValid(value) {\n    return /([01][0-9]|2[0-3]):[0-5][0-9]?:[0-5][0-9]/.test(value);\n  }\n\n  function dateIsValid(value) {\n    return /(\\d{4})-(\\d{2})-(\\d{2})/.test(value);\n  }\n\n  //  The Bootbox object\n  return exports;\n}));"],"file":"bootbox.min.js"}