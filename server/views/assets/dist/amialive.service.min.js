/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./js/utils/sse.utils.js":
/*!*******************************!*\
  !*** ./js/utils/sse.utils.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "asyncParse": () => (/* binding */ asyncParse),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "debounce": () => (/* binding */ debounce)
/* harmony export */ });
/* harmony import */ var flatted__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatted */ "./node_modules/flatted/esm/index.js");


const asyncParse = async function (str) {
  try {
    return (0,flatted__WEBPACK_IMPORTED_MODULE_0__.parse)(str);
  } catch (e) {
    return false;
  }
};
const isFunction = function (functionToCheck) {
  return functionToCheck && {}.toString.call(functionToCheck) === "[object Function]";
};

const debounce = function (func, wait) {
  let timeout;
  let waitFunc;
  return function () {
    if (isFunction(wait)) {
      waitFunc = wait;
    } else {
      waitFunc = function () {
        return wait;
      };
    }

    const context = this,
      args = arguments;
    const later = function () {
      timeout = null;
      func.apply(context, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, waitFunc());
  };
};


/***/ }),

/***/ "./node_modules/flatted/esm/index.js":
/*!*******************************************!*\
  !*** ./node_modules/flatted/esm/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "stringify": () => (/* binding */ stringify),
/* harmony export */   "toJSON": () => (/* binding */ toJSON),
/* harmony export */   "fromJSON": () => (/* binding */ fromJSON)
/* harmony export */ });
/*! (c) 2020 Andrea Giammarchi */

const {parse: $parse, stringify: $stringify} = JSON;
const {keys} = Object;

const Primitive = String;   // it could be Number
const primitive = 'string'; // it could be 'number'

const ignore = {};
const object = 'object';

const noop = (_, value) => value;

const primitives = value => (
  value instanceof Primitive ? Primitive(value) : value
);

const Primitives = (_, value) => (
  typeof value === primitive ? new Primitive(value) : value
);

const revive = (input, parsed, output, $) => {
  const lazy = [];
  for (let ke = keys(output), {length} = ke, y = 0; y < length; y++) {
    const k = ke[y];
    const value = output[k];
    if (value instanceof Primitive) {
      const tmp = input[value];
      if (typeof tmp === object && !parsed.has(tmp)) {
        parsed.add(tmp);
        output[k] = ignore;
        lazy.push({k, a: [input, parsed, tmp, $]});
      }
      else
        output[k] = $.call(output, k, tmp);
    }
    else if (output[k] !== ignore)
      output[k] = $.call(output, k, value);
  }
  for (let {length} = lazy, i = 0; i < length; i++) {
    const {k, a} = lazy[i];
    output[k] = $.call(output, k, revive.apply(null, a));
  }
  return output;
};

const set = (known, input, value) => {
  const index = Primitive(input.push(value) - 1);
  known.set(value, index);
  return index;
};

const parse = (text, reviver) => {
  const input = $parse(text, Primitives).map(primitives);
  const value = input[0];
  const $ = reviver || noop;
  const tmp = typeof value === object && value ?
              revive(input, new Set, value, $) :
              value;
  return $.call({'': tmp}, '', tmp);
};

const stringify = (value, replacer, space) => {
  const $ = replacer && typeof replacer === object ?
            (k, v) => (k === '' || -1 < replacer.indexOf(k) ? v : void 0) :
            (replacer || noop);
  const known = new Map;
  const input = [];
  const output = [];
  let i = +set(known, input, $.call({'': value}, '', value));
  let firstRun = !i;
  while (i < input.length) {
    firstRun = true;
    output[i] = $stringify(input[i++], replace, space);
  }
  return '[' + output.join(',') + ']';
  function replace(key, value) {
    if (firstRun) {
      firstRun = !firstRun;
      return value;
    }
    const after = $.call(this, key, value);
    switch (typeof after) {
      case object:
        if (after === null) return after;
      case primitive:
        return known.get(after) || set(known, input, after);
    }
    return after;
  }
};

const toJSON = any => $parse(stringify(any));
const fromJSON = any => parse($stringify(any));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!********************************!*\
  !*** ./js/amialive.service.js ***!
  \********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_sse_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/sse.utils */ "./js/utils/sse.utils.js");



const reloadWindow = async function () {
  if (location.href.includes("submitEnvironment")) {
    const hostName = window.location.protocol + "//" + window.location.host + "";
    window.location.replace(hostName);
    return false;
  } else {
    window.location.reload();
    return false;
  }
};

// Keeping hold of this, may return a use for later...
// function checkUpdateAndNotify(updateResponse) {
//   if (!!updateResponse?.update_available && !pageReloadPersistedRead) {
//     // Show the notification once per page load
//     pageReloadPersistedRead = true;
//     // Disregard notification if it it's version is already stored
//     let parsedStorageReleaseInfo;
//     try {
//       parsedStorageReleaseInfo = JSON.parse(localStorage.getItem(notificationMarkReadSessionKey));
//     } catch (e) {
//       parsedStorageReleaseInfo = null;
//     }
//     // If the update button is available, we are on the system page. React to available updates accordingly.
//     let updateOctoFarmBtn = document.getElementById("updateOctoFarmBtn");
//     if (updateOctoFarmBtn) {
//       updateOctoFarmBtn.disabled = false;
//     }
//     // Process the full notification or a shorter reminder
//     if (
//       !parsedStorageReleaseInfo ||
//       parsedStorageReleaseInfo?.tag_name !== updateResponse?.latestReleaseKnown?.tag_name
//     ) {
//       if (window.location?.href.includes("/system")) {
//         return;
//       }
//
//       var n = new noty({
//         type: "success",
//         theme: "bootstrap-v4",
//         layout: "bottomRight",
//         text: updateResponse?.message,
//         buttons: [
//           noty.button(
//             "UPDATE",
//             "btn btn-success",
//             function () {
//               window.location = "/system";
//             },
//             { id: "button1", "data-status": "ok" }
//           ),
//           noty.button("Mark read", "btn btn-error", function () {
//             // Update the stored version to become the newest
//             localStorage.setItem(
//               notificationMarkReadSessionKey,
//               JSON.stringify(updateResponse.latestReleaseKnown)
//             );
//             n.close();
//           }),
//           noty.button("Later", "btn btn-error", function () {
//             n.close();
//           })
//         ]
//       });
//       n.show();
//     } else {
//       UI.createAlert(
//         "success",
//         `A small reminder: OctoFarm update available from ${updateResponse.current_version} to ${updateResponse?.latestReleaseKnown?.tag_name} ;)`,
//         1000,
//         "clicked"
//       );
//     }
//   }
// }
// reconnectFrequencySeconds doubles every retry
let reconnectFrequencySeconds = 3;
let evtSource;
let countDownInterval = false;
let triggerTimeout = false;
let countDownSeconds = 0;
let reloadListenerAdded = false;

const reconnectFunc = (0,_utils_sse_utils__WEBPACK_IMPORTED_MODULE_0__.debounce)(
  function () {
    setupEventSource();
    // Double every attempt to avoid overwhelming server

    reconnectFrequencySeconds *= 2;
    // Max out at ~1 minute as a compromise between user experience and server load
    if (reconnectFrequencySeconds >= 64) {
      reconnectFrequencySeconds = 64;
    }
  },
  function () {
    return reconnectFrequencySeconds * 1000;
  }
);

function triggerCountDownTimer(seconds){
  countDownSeconds = seconds;
  if(!countDownInterval){
    countDownInterval = setInterval(() => {
      if(reconnectFrequencySeconds <= 1){
        //reset the counter
        clearInterval(countDownInterval)
        countDownInterval = false;
      }else{
        countDownSeconds = countDownSeconds - 1
        document.getElementById("lostServerConnectionTimer").innerHTML = countDownSeconds;
      }
    },1000)
  }
}

function setupEventSource() {
  evtSource = new EventSource("/amialive");
  evtSource.onmessage = async function (e) {
    if (e?.data !== null) {
      window.serverOffline = false;
      await (0,_utils_sse_utils__WEBPACK_IMPORTED_MODULE_0__.asyncParse)(e.data);
      const lostServerConnectionModal = document.getElementById("lostServerConnection");
      if (lostServerConnectionModal && lostServerConnectionModal.className.includes("show")) {
        // If user has login enabled then we need to refresh the session...
        if(!!e.data.loginRequired){
          await reloadWindow()
        }else{
          await closeModal();
        }

      }
    }
  };
  evtSource.onopen = function (e) {
    console.debug("Connected to servers Am I Alive stream...");
    // Reset reconnect frequency upon successful connection
    reconnectFrequencySeconds = 3;
  };
  evtSource.onerror = async function (e) {
    window.serverOffline = true;
    console.debug("Server connection lost! Re-connecting in... " + reconnectFrequencySeconds + "s");
    triggerCountDownTimer(reconnectFrequencySeconds)
    console.error(e);
    await drawModal();
    evtSource.close();
    reconnectFunc();
  };
  evtSource.onclose = async function (e) {
    window.serverOffline = true;
    console.debug("Server connection closed! Re-establishing..." + reconnectFrequencySeconds + "s");
    triggerCountDownTimer(reconnectFrequencySeconds)
    console.warn(e);
    await drawModal();
    evtSource.close();
    reconnectFunc();
  };

}

const drawModal = async function () {
  if(!reloadListenerAdded){
    document.getElementById("forceRefreshPageButton").addEventListener("click", () => {
      reloadWindow();
    })
  }

  if(!triggerTimeout){
    triggerTimeout = setTimeout(() => {
      $("#lostServerConnection").modal("show");
      triggerTimeout = false;
    },2000)
  }
};
const closeModal = async function () {
  $("#lostServerConnection").modal("hide");
};

setupEventSource();

})();

/******/ })()
;
//# sourceMappingURL=amialive.service.min.js.map